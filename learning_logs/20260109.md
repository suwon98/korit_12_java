# Object 클래스
- _모든 클래스는 Object 클래스를 상속_ 받는다. 그래서
interface를 implements 할 때나 다른 서브 클래스를 만들어서
extends 입력했다고 했을 때 우리가 직접 만들었던 슈퍼 클래스
이외에 alt + ins 눌러보면 toString() 어쩌고 한 메서드들이
추가되어있었습니다.

1. toString() : 기본적으로 모든 클래스는 Object 클래스를 상속
받아서 클래스 이름과 해시코드(일종의 주소지 개념)를 return함.
    - 이를 Override하여 재정의하고 클래스의 정보를 출력할 때 사용함.
    - field를 정의하고, toString() 메서드를 override해서 필요한
    field들을 출력함(name만 혹은 adrdress만도 가능합니다). ->
    추가적으로 객체의 이름만으로 출력이 가능하기 때문에
    `System.out.println(객체명.toString())`이 아니라,
    `System.out.println(객체명)`로 할 수 있습니다.
2. equals() : String에서의 두 객체가 '논리적으로 같은지'를 비교하는 메서드
(주소지의 차이가 아니라). 기본적으로 Object 클래스의 equals()메서드는
두 객체의 참조 주소를 비교합니다.
    - 형식 : 객체명1.equals(객체명2) : 객체명1과 객체명2의 참조
    주소가 동일한지를 확인함. - 3형식 문장으로 해석하시면 됩니다. SVO
3. hashCode() : 객체를 정수값(해시값)으로 변환(16진수가 아니라).
해시 값은 주로 해시 기반 컬렉션에서 사용됩니다(추후 사용).
    - equals() 메서드를 재엉의하게 되면 반드시 hashCode()
    메서드도 재정의 해야만 합니다. 왜냐면 동일한 객체(equals == true)
    는 동일한 해시 코드를 가져야 하기 때문인데, 문제는 해시 코드가
    같다고 해서 또 equals()가 true가 아닌 경우가 있기 때문입니다.

# Lombok
좌측 상단의 메뉴바 -> 설정(ctrl + alt + s) -> 좌측에 plugins(플러그인)선택
-> lombok 검색 -> 설치 후 disabled / 비활성화 라고 뜨면 롬복을 설치 후 활성화 되었다는 의미입니다.

chrome -> mvn 검색 -> maven repositories 로 들어가서 lombok 검색 -> 웬만하면 최신 버전
-> 그리고 저희가 첫 날에 gradle에 groovy로 만들었습니다 -> 그래서 groovy short복사한 후에
build.gradle로 가서 annotationProcessor도 빼먹지 말고 이하와 같이 추가해줍니다.
```java
dependencies {
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    implementation 'org.projectlombok:lombok:1.18.42'
    annotationProcessor 'org.projectlombok:lombok:1.18.42'
}
```
그리고 아무 클래스나 들어가서 `@Getter` 등을 입력했을 때 경로가 Lombok으로 나오면 적용이 성공했음을 알 수 있다.

## Lombok 주요 annotation
1. @ Getter / @Setter
 - class level에 작성할 경우 모든 getter / setter 메서드를 자동 생성
 - field level에 작성할 경우 해당 field에만 메서드 생성
 - 주의 : 객체마다 다른 값을 갖게 되는 비정형(non-static) field에만 해당됨.

 ```java
 @Setter
 @Getter
 public class Person {
    private String name;
    private int age;
 }
 ```

 2. @ToString
    - toString() 메서드를 자동 생성. 문제는 재정의가 안되고 Lombok 라이브러리
    default 형태만 나오기 때문에 원하는 부분만 보여주기 위해서는
    override 할 필요가 있습니다.

3.  @EqualAndHashCode
    - equals() / hashCode() 메서드를 자동 생성. 객체의 동일성 비교 로직을 구현할 때 사용.
        - 아까 학습한 것처럼 equals()를 재정의하면 hashCode()도 반드시
        재정의 해야하기 때문에 롬복에서는 세트로 묶어놨습니다.

4. @NoArgsConstructor / @RequiredArgsConstructor / @ALLArgsConstructor
    - @NoArgsConstructor : 매개변수가 없는 기본 생성자를 생성
    - @RequiredArgsConstructor : final 또는 `@NonNull` 애너테이션이 붙은
    field만 필수적으로 요구하는 매개변수 생성자를 생성
    - @ALLArgsConstructor : 모든 field를 argument로 요구하는 매개변수 생성자

5. @Data
    - @Getter / @Setter / @ToString / @EqualsAndHashCode / @RequiredArgsConstructor
    가 다 들어가있는 종합 패키지 애너테이션.

6. @Builder - 추후 수업 예정

# Static

## 정의
    - 클래스 수준에서 변수를 정의하거나 메서드를 선언할 때 사용
    - static으로 선언된 변수나 메서드는 클래스의 '인스턴스에 속하지 않음.'(즉 객체마다
    다른 값을 가지는 것이 인스턴스 변수였는데, 그게 아니라 해당 클래스의 인스턴스가 전부 동일한 값을 공유함을 의미합니다.)
    - 클래스 자체에 속하게 됨.
    - 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 field, method와 구분됩니다.

## 특징
    1. 공유 : 모든 인스턴스가 동일한 static 변수에 접근합니다. 따라서 데이터를
    공유하거나 상태를 저장할 때 유용.
    2. 클래스 수준의 변수 및 메서드 : static 변수와 메서드는 클래스 로드 시 메로리에 할당
    (객체가 생성될 때가 아니라).

```java
// 일반 field에 미리 초기화를 해두는 방식 : 객체가 생성될 때마다 동일한 내용이 반복적으로 메모리에 할당됨.
@Setter
@Getter
public class KoreaItSutdent12 extends KoreaItStudent {

    // field 선언
    private String name;
    private int age;
    private String address;
    private String introduction = "코리아 아이티 국비 과정 12월";
}

public class Main {
    public static void main(String[] args) {
        KoeraItStudent12 student1 = new KoeraItStudent12();
        student1.setName("김일");
        student1.setAge(20);
        student1.setAddress("부산광역시 부산진구");
        System.out.println(student1.getIntroduction()); // 결과값 : 코리아 아이티 국비 과정 12월
    }
}
```

```java
// 정적 변수의 선언으로 클래스가 메모리에 마운트 될 때 1 번 저장
// 이후 객체가 생성될 때마다 동일한 introduction field를 가지게 됨.
@Setter
@Getter
public class KoreaItSutdent12 extends KoreaItStudent {
    // 정적 변수 선언
    private static String introduction = "코리아 아이티 국비 과정 12월";
    // field 선언
    private String name;
    private int age;
    private String address;
    private String introduction = "코리아 아이티 국비 과정 12월";
}

public class Main {
    public static void main(String[] args) {
        KoeraItStudent12 student1 = new KoeraItStudent12();
        student1.setName("김일");
        student1.setAge(20);
        student1.setAddress("부산광역시 부산진구");
        System.out.println(student1.getIntroduction()); // 결과값 : 코리아 아이티 국비 과정 12월
    }
}
```

이상의 KoreaItStudent12 클래스의 인스턴스들은 다 동일한 private static String `정적 변수`를 갖게 됩니다.
즉, 어느 클래스의 인스턴스인지만 확인하더라도 몇 월 국비생인지를 확인할 수 있겠네요.
    3. 인스턴스가 필요없음 : 객체를 생성하지 않고도 클래스명.field / 클래스명.메서드명()
    형태로 접근이 가능합니다(이때는 private이 아니어야겠네요)

    4. 메모리 효율성 : static 변수는 프로그램이 종료될 때까지 한 번만 메모리에 할당됨(객체가 생성될 때마다가 아니라).

# Builder Pattern(빌더 패턴)
```java
@ALLArgsConstructor
public class Student {
    private int code;
    private String name;
    private String gender;
    private String school;
    private int semester;
    private String[] subjects;
    private double[] scores;
}
public class StudentMain {
    public static void main(String[] args) {
        Student student = new Student (여기 내부에 모든 field를 순서대로 작성해야합니다.);
    }
}
```

## 빌더 패턴이 생기게 된 원인
1. 복잡한 생성자 문제
    - 객체의 field가 많아질수록 생성자 매개변수 수도 늘어남.
        - 저희는 롬복 쓰니까 생성자 코드 라인이 적을 수 있지만
        - 필수적인 부분에 @NonNull이나 final을 써야하고, 그와중에 final 쓰면 기본
        생성자는 못만드는 등 여러가지 제약이 있습니다.
2. 생성자 오버로딩 문제
    - 생성자에 필요한 조합이 다를 경우 수많은 생성자를 하나씩 정의해야 합니다.
        - 예를 들어 옛날 회원가입의 경우 집전화와 폰번호가 필수였는데, 오늘날에는 집전화는
        optional인 상태죠. 그럼 처음에는 homePhone field에 final 넣었었다가 나중에는
        뺐다가 그러면 거기에 맞춰서 생성자도 homePhone field를 넣어놨었는데 나중에는
        그거 삭제해야하고 하여튼 귀찮은 상황이 발생합니다.

    - 유지보수에 악영향 / 예를 들어서 field 하나 추가하면 AllArgsConstructor가 아니게 되니까
    다 뜯어 고쳐야겠네요. 저희가 VolumUpButton 추가했을 때 생성자 뜯어내고 Main에서
    생성자 호출할 때도 오류 수정했던 것을 떠올리면 되겠습니다.

3. 가독성 문제
    - 코드를 작성하고 읽는 입장에서는 객체를 생성할 때 어떤 값이 어떤 field에 해당하는지
    명확하지 않아서 실수를 유발할 수 있음.

```java
public static void main(String[] args) {
    Student student = new Student("김일", "김이");
}
```
라고 했을 때 얘가 김일 학생인데 김이 초등학교인지 / 김일 초등학교인데 김이 학생인지 알바가 없다는 겁니다.

## 정의
객체의 생성과정에서 '복잡한 생성자'를 대신하여 '단계적으로' 객체를 생성할 수 있는
디자인 패턴 중 생성 파트 관련. GoF(Fang of Four) 디자인 패턴 중 하나로
객체 생성 시 가독성과 유연성을 제공하는 것이 목표.

- 이상에서의 유연성의 의미는 field를 '순서대로' 채워넣지 않아도 되고, 순서를 바꾸더라도
정확한 field에 원하는 값을 집어넣을 수 있다는 것을 의미합니다.

## 특징
1. 객체를 생성하는 여러 개의 field를 '명시적'으로 관리할 수 있음.
2. 불필요한 생성자 오버로딩을 줄여 가독성을 높임.
3. 체이닝 메서드를 사용하여 객체를 직관적으로 생성