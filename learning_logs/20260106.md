# 상속(Inheritance)
- 객체 지향 프로그래밍(Object-oriented Programming : OOP)의 핵심 개념 중 하나로,
기존 클래스(부모(슈퍼) 클래스)의 field와 method를 재사용하여 새로운 클래스(자식(서브) 클래스)를 만드는 것을 의미함

## 상속의 필요성
- 상속을 통해 공통적인 기능을 부모 클래스에 정의하고, 이를 '여러' 자식 클래스가 재사용 가능
    - 동물(Animal) 클래스가 있고, 이를 상속 받는 개(Dog), 고양이(Cat) 클래스가 있다고 가정했을 때, 동물의 공통적인 field(이름 / 나이 등)와 행위-method(걷기 / 먹기 등)을 부모 클래스에 정의하고, 개와 고양이는 각각 고유한 특성(짖기 / 우다다다 등)을 추가할 수 있음.
- 이상의 과정을 거쳤을 때 얻을 수 있는 이점 :
    - Dog에 이름 / 나이 / 걷기 / 먹기 / 짖기를 정의하고,
    - Cat에 이름 / 나이 / 걷기 / 먹기 / 우다다다를 정의하는 등의 공통된 부분을
    정의하는 일 없이 고유 속성 및 method만 정의하면 됨
    - 결과적으로 _중복된 코드를 줄일 수 있다_

## 상속의 특징
    1. 단일 상속
        - Java는 단일 상속만 지원함. 하나의 클래스는 한 번에 하나의 부모 클래스만 상속 받을 수 있어 상속 구조가 간단하고 명확함.
    2. super 키워드
        - 클래스의 생성자 및 setter에서 학습한 this와 유사한 개념으로 부모 클래스의 field에 접근하거나 부모 클래스의 생성자를 호출하거나 / 메서드를 호출할 때 사용(두 가지 사용법이 있습니다 - 추후 설명)
    3. _method override_
        - 자식 클래스에서 부모 클래스의 기본 동작을 `재정의` 할 수 있음.
        이를 통해 자식 클래스는 부모 클래스의 기본 동작을 자신만의 방식으로 변경 가능.
        - 예시
            - Aniaml 클래스의 걷기 method를 Dog가 상속 받고, _네 발로 걷기_ 로 재정의하고, Human 클래스가 걷기 method를 상속 받고 _두 발로 걷기_ 로 재정의가 가능합니다.

    4. final 키워드 : 클래스에 final이 붙으면 상속 불가
    5. method에 final이 붙을 경우에는 method override가 불가능

## 장점
    1. 코드의 재사용성 - 동일한 코드를 반복적으로 작성할 필요 X
    2. 유지 보수의 용이성
        - 부모 클래스의 변경 사항이 자식 클래스에 자동으로 반영되기 때문에 위계를 파악한 후에 수정하시면됩니다.
    3. 객체 간 관계 표현 - IS-A 관계를 명확히 나타냄.
        - IS-A : '개'는 '동물'의 일종이다. 와 같은 예시로 IS-A는 is a kind of의 축약어에 해당함.
        - 그래서 우리가 미리 만들어둔 Animal / Tiger / Human 클래스를 예로 들었을 때, Human / Tiger는 Animal 클래스의 자식(서브) 클래스다. 라고 해석할 수 있습니다.

        - 좀 더 일반적이고 넓은 범위를 가지는 것이 부모 클래스가 될 것이고, 좀 더 구체적이고 특징지어진 것이 자식 클래스가 될 것입니다.

## Override
    - @Override가 되어있는 부분은 상위 클래스로 부터 상속 받은 메서드임을 의미함.
        -> @Override가 없으면 고유 메서드라는 뜻일 것이고,
        클래스에 없는 메서드를 호출한다면 부모 클래스의 메서드를 '그대로' 쓰는 것이고,
        @Override가 있다면 부모 클래스의 메서드를 호출하여 '재정의'가 되어있다고 볼 수 있다.
    - super 키워드 -> 부모 클래스의 임의의 인스턴스를 의미한다.

## 기본 생성자 없이 상속
    - 부모 - 자식의 상속 관계가 성립되어 있을 때,
    부모 클래스에서 기본 생성자 없이 매개변수 생성자만 있다면,
    자식 클래스에서 완벽한 기본 생성자를 만드는 것이 '불가능'합니다.

    자식 클래스의 객체를 생성 시 필수적으로 '부모 클래스의 생성자 호출'을 하기 때문입니다.
    자식 클래스에서 정의되지 않은 일부 필드와 메서드를 어떻게 사용할 수 있냐면
    부모 클래스의 객체를 생성한 다음에 자식 클래스에서 고유 필드와 메서드를 더하여
    합치는 과정을 거치기 때문에 사용이 가능합니다.

    그래서 부모 클래스의 생성자 정의 방식을 따르지 않으면
    자식 클래스에서 오류가 발생하는 경우가 있습니다.

    또한 어떤 객체를 생성할 때
        A a = new A(); 같은 방식으로 많이 생성했지만,
        A a = new B(); 같은 방식으로 생성하는 경우도 볼 수 있다.

## super 키워드

1. super() : 부모 클래스의 생성자를 호출
2. super.메서드명() : 부모 클래스의 메서드를 호출


# 다차원 배열(Multi-Dimensional Array)
    : 다차원 배열은 2차원 이상의 배열을 의미하지만 개발 환경 상 2차원 배열 이상을 다루는 경우는 드물기 때문에 2차원 배열을 기준으로 강의.

    형식 : 
        int[][] arr01 = new int[크기][크기];        - 선언 방식 # 1
        int[][] arr02 = new int[크기][];            - 선언 방식 # 2
        int[][] arr03 = { {1, 2}, {3, 4}, {5, 6} }  - 선언 방식 # 3 및 초기화
    
    2차원 배열 선언 시, '열'의 크기는 지정하지 않아도 되지만 '행'의 크기는 항상 지정해야함
    -> 선언 방식 # 2 참조
            1열 2열(column)             - 세로줄을 열
        {    ↓  ↓ 
            {1, 2},     → 1 행 (row)    - 가로줄을 행
            {3, 4},     → 2 행 (row)
            {5, 6}      → 3 행 (row)
        }
    - 내부 element 추출
        예시
```java
    int[][] arr03 = { {1,2}, {3,4}, {5,6} };
    for(int i = 0; i < arr03.length; i++) { // 1차 배열 반복문
        for(int j = 0; j < arr03[i].length; j++) {  // 2차 배열 반복문
            System.out.print(arr03[i][j])
        }
    }
```
        향상된 for문을 통한 예시
```java
    for(int[] firstArray : arr03) { // 1차 배열 반복문
        for(int secondElement : firstArray) {   //2차 배열 반복문
            System.out.print(secondElement)
        }
    }
```