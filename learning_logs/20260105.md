# 향상된 for문(enhanced for loop)
## 일반 for 문 과의 차이점 :
    - 일반 for 문의 경우 index 넘버(주소지)를 명확하게 알고 있어야 하지만 일일이 element의 숫자를 세는 것이 번거롭기 때문에
        arr01.length와 같은 일종의 field 참조를 통해 int 값을 추출하여 대입해야만 했습니다.

        그런데 for (int i = 0; ... ) 부분에서 int i는 for문 내부에서만 선언되고, 내부에서만 사용이 가능합니다.

        이를 응용해서 배열 내의 element에 for 문 내부에서만 사용하는 변수에 대입하는 방식을 사용하여
        index 넘버의 사용 없이 적용할 수 있는 for 반복문이 있는데, 이를 향상된 for문이라고 합니다.

    - 제약 : 
            읽기만 되고, 쓰기가 안됩니다.
    - 형식 : 
            for(자료형 변수명 : 반복가능객체(배열)) {
                반복실행문
            }
```java
    int[] numbers = {1, 2, 3, 4, 5};
    for(int number : numbers) {
        System.out.println(number);
    }
```

## 배열의 출력
    - 엄밀히 말하면 지금까지 배열을 출력한게 아니라 배열 내부의 element들을 출력해왔습니다.
        System.out.println(arr01);과 같은 출력문을 작성했을 때, 주소값이 튀어나온다는 사실을 확인할 수 있습니다.

        element의 값을 조정하거나, 더하거나 등의 추가적인 가공을 하기 위해 for문을 사용해왔는데,
        굳이 변형이 없고 배열 자체에 값이 들어갔는지만 확인하기 위해 
        매번 반복문을 작성하거나 method를 정의해서 호출해야 하는지 의문이 듭니다.

    - Arrays 클래스를 사용하고, '정적' 메서드인 .toString(배열명)을 사용하면 배열 전체를 출력할 수 있습니다.
        여기서 중요한 점은 클래스명.메서드명() 이라는 점입니다.
        scaaner.nextInt();의 경우 객체명.메서드명()이었는데 차이가 있습니다.
        그리고 toString()이라는 메서드도 있습니다.
        위에서 확인해야 할 부분은 동일한 method 명이라고 하더라도
        어떤 클래스에 종속되어있는가에 따라 다른 결과값을 지닐 수 있다는 점입니다.
    -동일한 메서드 명이지만 클래스에 따라 서로 다른 로직일 수 있다는 예시
```java
        Random random = new Random();   // 랜덤 클래스의 객체 생성
        Scanner scanner = new Scanner(System.in);   // 스캐너 클래스의 객체 생성
        int num1 = random.nextInt();
        System.out.println("숫자를 입력하세요 >>> ");
        int num2 = scanner.nextInt();
        System.out.println(num1);
        System.out.println(num2);
        // 이상의 경우에서 random.nextInt();는 int 범위 내에서 임의의 정수를 생성하는 메서드이고, 
        // scanner.nextInt();는 int 값을 콘솔에서 입력하는메서드라는 점을 알 수 있습니다.
        // 즉, 같은 method명이면서도 어떤 클래스의 객체에서 호출하느냐에 따라서 결과값이 다릅니다.
```
## 배열의 출력
    - 배열의 출력
        Arrays.toString(배열명);
        배열 전체 출력 예시
```java
    System.out.println(Arrays.toString(numbers));
```
    
    - 배열의 정렬(오름차순)
        Arrays.sort(배열명);
        배열의 정렬(오름차순) 예시
```java
    Arrays.sort(numbers);
```
        sort의 return 타입이 void입니다.
        정렬 후 numbers의 배열을 확인해보면 numbers의 원본 배열을 통째로 바꿨다는 점을 알 수 있습니다.
        System.out.println(Arrays.toString.sort(nums));
        이상의 코드는 그래서 오류가 납니다. 먼저 바꿀건지 먼저 출력할건지 모르기 때문 입니다.
        Arrays.sort(nums);의 결과값이 void기 때문에 return이 없는데 
        Arrays.toString();에는 배열을 넣어야만 하기 때문에 오류가 발생합니다.
    
    - 배열의 정렬(내림차순)
        Arrays.sort(배열명, Comparator.reverseOrder());
        (이 때 int 배열이라면 Integer 배열로 변환하여 사용한다 
        -> 기본 자료형(primitive types)인 int[] 배열을 사용할 수 없어서 Integer[]배열을 사용)

        배열의 정령(내림차순) 예시
```java
Arrays.sort(numbers, Comparator.reverseOrder());
```
        내림차순 정렬은 method overloading의 예시라고 할 수 있습니다.
            sort() 메서드에 오름차순에서는 argument가 하나 있는데, 내림차순에서는 argument가 두 개 이기 때문입니다.
        오름차순과 마찬가지로 원본 배열을 바꿉니다.
        두 번째 argument로 Comparator.reversrOrder()가 사용되었는데,
        메서드의 결과값이 sort()의 두 번째 argument로 사용되었다는 점에서 함수형 프로그래밍의 일종이라고 볼 수 있습니다.
    