# Java Review

1. 자료형(type)
    1. 기본 자료형(primitive Types)
       1. 숫자 관련
          - 정수 관련
              - int, long
          - 실수 관련
              - double, float
        - 왜 두개씩 있나? : 용량 문제 ch04_conversion 확인
        2. 문자 관련
           - 문자(char)
    2. 참조 자료형(Reference Types)
        1. 문자 관련
            - 문자열(String) : 문자가 '순서대로' 나열 되어있다는 점. 
                - 안근수 / 수근안 : 동일한 문자들로 구성되어있지만 순서가 다르기 때문에 차이가 있음.
                - 안 + 근 + 수 / 수 + 근 + 안 의 결과값이 다릅니다.
                - 숫자의 경우에는 1 + 2 + 3 / 3 + 2 + 1이 결과값이 동일한 것과는 차이가 있습니다.
2. 변수(Variable) : 데이터(값)를 담는 바구니(인데 이름을 붙여줘야함).
    1. 변수 명명 규칙
        - camel case를 사용할 것.
            - camel case : 시작은 소문자로, 다수의 단어로 이루어졌을 경우 두 번째 이후 단어의 첫 번째 알파벳은 대문자로 입력할 것.
            - 예시 :
                - 단수 단어 : result
                - 복수 단어 : myTestResult
        - Pascal case : 시작을 대문자로, 다수의 단어로 이루어졌을 경우 두 번째 이후 단어의 첫 번째 알파벳은 대문자를 입력할 것, 나머지는 소문자
            - 예시 :
                - 단수 단어 : Result
                - 복수 단어 : MyTestResult
    2. 변수 선언 및 초기화
```java
public static void main(String[] args) {
    // 자료형 변수명 = 데이터;   -> 주석 다는 방법도 했었음.
    int  age = 20;
    
    // 변수 선언 : 앞으로 해당 변수가 사용될거라는 것을 선언(declaration)
    String name;
    // 초기화 : 특정 변수에 처음으로 값을 대입하는 것.
    name = "김일";
    // 재대입 : 특정 '변수'에 값을 바꿔주는 것.
    name = "김이";
}
```
    3. 상수 : 데이터가 초기화 이후 재대입이 불가능한 변수를 의미함.
```java
public static void main(String[] args){
// final 자료형 변수명 = 데이터;
    final int AGE = 12; // 상수라는 것을 알리기 위해서 camel case를 쓰지 않고 대문자로 작성함.
    // age = 13;    - 재대입하려고 하면 오류가 발생함
}
```
    - 상수 명명 규칙
        -camel case를  적용하지 않고 전부 다 대문자로 작성함. 복수 단어로 이루어져있을 경우 단어 경계에 언더바(언더스코어 : '_')를 사용.
        - 예시 :
            1. 단수 단어 : RESULT
            2. 복수 단어 : MY_TEST_RESULT
3. Conversion(형변환) : 특정 변수(객체)를 다른 자료형으로 변환시키는 것.
    1. upscasting : 특정 변수(객체)를 더 큰 용량의 자료형으로 변환시키는 것.
        - 암시적(implicit)으로 이루어짐 : 작은 용량에서 큰 용량으로 변환시킬 때는 데이터의 값이 변질되지 않기 때문에 직접적으로 바뀔 자료형을 명시하지 않아도 됨
    
    2. downcasting : 특정 변수(객체)를 더 작은 용량의 자료형으로 변환시키는 것.
        - 명시적(explicit)으로 이루어짐 : 더 큰 용량에서 작은 용량으로 바꾸게 될 경우 용량 제한으로 인해 데이터의 값이 변질될 수 있기 때문에 직접적으로 자료형을 명시해야만 함.
```java
public static void main(String[] args){
    // 업캐스팅 용 변수 선언 및 초기화
    char cast1 = 'A';
    
    // 1. 업캐스팅 # 1 : (바뀔데이터타입)변수명;
    System.out.println("변형 : " + (int)cast1); // 결과값 : 65
    // 2. 업캐스팅 # 2
    int casted1 = cast1;    // 이 부분이 '암시적(implicit)'
    
    // 다운캐스팅 용 변수 선언 및 초기화
    int cast2 = 97;
    // 3. 다운캐스팅 # 1 : (바뀔데이터타입)변수명;
    System.out.println("변형 : " + (char)cast2);  // 결과값 : a
    // 4. 다운캐스팅 # 2
    char casted2 = (char)cast2;     // 이 부분이 '명시적(explicit)' - 업캐스팅 # 2와의 차이점 확인하세요
}
```

4. Operator(연산자)
    1. 대입 연산자 '=' : '=' 왼쪽에 있는 변수에 '=' 오른쪽에 있는 데이터(값)를 '대입'한다는 의미 - 즉 a=b라고 했을 때 a와 b의 값이 같다 라는 의미가 아니라는 점에 주목해야 합니다.
        - 같다고 이야기 하고 싶다면 '=='을 씁니다. 근데 JavaScript에서는 '=='도 있고 '==='도 있습니다.
    2. `+ - * /` : 수학이랑 똑같습니다. - 문자, 문자열 자료형의 경우에도 + 연산자는 적용이 가능.
    3. % : 나머지 연산자 - 나누고 나서 남는 나머지를 명시함. 즉 결과값은 int, long이어야 함.
    4. 복합대입연산자
        1. +=
        2. -=
        3. *=
        4. /=
    5. `++ / --`
```java
public static void main(String[] args){
    int num = 1;
    System.out.println(num++); // 결과값 : 1
    System.out.println(num);   // 결과값 : 2
    System.out.println(++num); // 결과값 : 3
    System.out.println(num);   // 결과값 : 3
    System.out.println(num--); // 결과값 : 3
    System.out.println(num);   // 결과값 : 2
    System.out.println(--num); // 결과값 : 1
}
```
5. Condition 조건문 : 조건식 내의 return값이 true / false에 따라서 특정 부분을 실행시키는 제어문
```java
public static void main(String[] args) {
    if (조건식1) {
        실행문1
        if (조건식1 - a) {
            실행문1 - a
        } else if (조건식1 - b) {
            실행문1 - b
        } else if (조건식1 - c) {
            실행문1 - c
        } else {
            실행문1 - d
        }
        실행문1 - 2
    } else if (조건식2) {
        실행문2 - 1
    } if (조건식2-a){
        실행문2 - a
    }else{
        실행문2 - b
    }
    실행문2 - 2
    } else {
    실행문3
    }
}
```
    1. 용어 정리
        1. 조건식 : true / false로 결정이 날 수 있는 boolean 자료형을 return하는 식
        2. 실행문 : if, else if, else 이후의 {} 내의 영역으로 특정 조건을 만족했을 경우 실행되는 코드 혹은 식.
    2. 반복문과의 유의 사항
        - 반복문의 특정 조건을 만족했을 경우 '반복'실행되는데 반해, 
        조건문은 해당 조건에 해당되는 부분을 '한 번' 실행합니다. 그래서 if-else if-else 전체를
        한 세트로 봐야합니다.
    3. switch문
```java
public static void main(String[] args){
    // 사용할 클래스 import
    Scanner scanner = new Scanner(System.in);
    // 변수 선언 및 초기화

    System.out.println(" [ 메뉴 선택 ] ");
    System.out.println("1. Java 공부하기");
    System.out.println("2. JavaScript 공부하기");
    System.out.println("3. Python 공부하기");
    System.out.println("4. HTML 공부하기");
    System.out.println("Big Data 공부하기");
    
    System.out.print("메뉴를 선택하세요");
    int menu = scanner.nextInt();
    
    switch (menu){
        case 1 :
            System.out.println("Java를 공부하기로 하셨습니다!");
            break;
        case 2 :
            System.out.println("JavaScript 를 공부하기로 하셨습니다!");
            break;
        case 3 :
            System.out.println("Python 를 공부하기로 하셨습니다!");
            break;
        case 4 :
            System.out.println("HTML 를 공부하기로 하셨습니다!");
            break;
        case 5 :
            System.out.println("Big Data 를 공부하기로 하셨습니다!");
            break;
        default :
            System.out.println("오늘은 쉬기로 결정했습니다");
    }
}
```
6. Loop(반복문)
    1. while
```java
public static void main(String[] args){
    int i = 0;
    while(i < 100) {    // () 내부의 조건식이 true일 때 실행 - 무한 루프를 조심해야 함.
        if(i % 2 == 0) {
            System.out.println(i + "는 짝수입니다.");
        }else {
            System.out.println(i + "는 홀수입니다.");
        }
        i++;    // 특정 조건에서 while 반복문을 탈출하기 위해서 통제할 필요가 있음.
    }
}
```
    2. for
```java
public static void main(String[] args){
    // for (시작값 ; 한계값 ; 증감값)
    for(int i = 0; i < 100; i++){
        if(i % 2 == 0) {
            System.out.println(i + "는 짝수입니다.");
        }else {
            System.out.println(i + "는 홀수입니다.");
        }
    }
}
```
    3. 주의 사항
        - while문의 경우에는 무한루프에 빠지지 않도록 특정 조건 하에서 반복문을 탈출할 수 있게끔 작성할 필요가 있음.
        - for문의 경우에는 한계값을 초반부에 명시하고, 그 반복횟수를 int로 정리한다는 점을 생각해둘것.
        while문의 경우에는 조건식이 String일 수도 있죠.
            - 증감값을 통해 반복횟수를 통제한다는 점에서,

        - while 문 : 특정 조건 하에서만 반복실행되게 통제 할 때 사용.
        - for 문 : 명확한 반복 횟수를 통제할 때 사용.


## method overloading
     - 매개변수의 유무 및 자료형의 차이, 개수의 차이를 나눠서 동일한 메서드 명을 지닌 메서드들을 정의할 수 있다.
    - 즉, 메서드 명은 동일하고, 매개변수에 들어가는 자료형, 개수를 달리하게 되면 서로 다른 메서드로 인지하게 된다.
 # 예시
    -예를 들어 String 자료형끼리 연결해주는 메서드와
            int끼리의 합 연산을 하는 메서드를 나눈다고 가정했을 때,
            add,
            plus,
            connect 등을 정의했다면,
            다음 합 연산을 하는(예를 들어 double 자료형을 지니는) 메서드 명을 정하려고
            하면 번거롭습니다.
            이러한 부분을
            public void add(String example1, String example2) {
                로직
            }
             public void add(int example1, int example2) {
                로직
            }
             public void add(double example1, double example2) {
                로직
            }
            과 같이 자료형을 달리 하는 '동일한 이름을 가지는 메서드들'을 정의하거나
            public void add(double example1, double example2, double example3) {
                로직
            }
 
 # method overloading의 장점
    - 동일한 기능을 하는 메서드를 정의할 때 메서드 명이 필요한데, 예시와 같은 식으로 매개변수의 개수의 차이를 두더라도 '동일한 기능을 하는 서로 다른 메서드'들로 인식하게끔 하는 방식
    - 매개변수의 유형, 개수가 차이가 있지만 메서드 명들이 동일하고 기능이 같다는 장점. (동일한 메서드 명 = 동일한 기능)

## 클래스와 객체
# 클래스란 ?
    - 객체를 생성하기 위한 설계도 = 틀
    현실 세계의 개념을 프로그래밍으로 표현할 때, "특정 사물이나 개념의 특징(속성)"과 "행위(메서드)"로 정의함.
    - 예시 : 자동차로 예를 들면 속성(색상, 속도) / 행위(가속, 정지 등)를 코드로 표현할 수 있음.

# 객체(Object)란?
    - 클래스를 설계도로 가정했을 때, 실제로 사용할 수 있는 자동차(인스턴스)는 객체라고 함.

    - Object와 Instance는 우리나라에서는 거의 동일한 용어로 사용됩니다.

# 객체와 인스턴스 관계
    - 객체는 포괄적인 개념으로 클래스에서 생성된 모든 것을 객체라고 표현
    - 인스턴스는 특정 객체가 어떤 클래스의 구현체인지 강조하는 표현
    - 예시
        "사람"이라는 클래스가 있다고 가정, "홍길동", "김철수"는 이 클래스에서 생성된 객체. 근데 "아반떼"도 객체.
        "홍길동"은 "사람"이라는 특정 클래스의 '인스턴스'이다. 하지만 "아반떼"는 아님

## 생성자(Constructor)
    - 생성자는 객체가 생성될 때 호출되는 특별한 '메서드'
    객체 생성 예시
        클래스명 객체명 = new 클래스명();
        ClassExample example = new ClassExample();
        : 사실 ClassExample() 가 생성자에 해당
    - 특징
        1. 클래스의 이름과 생성자의 이름은 동일하다. (다른 메서드들과 달리 Pascal Case로 작성된다. method는 동사로 시작되는데, 이건 클래스 이름이랑 똑같으니까 명사)
        2. return 값이 없다. -> call1(), call2() 유형으로 생각할 수 있음.
    3. 객체 초기화 : 생성자는 객체의 필드 '초기화'를 담당한다.

    - 생성자의 정의 방식
        1. 기본 생성자 : 매개변수가 없는 생성자(클래스를 만들 때 default로 생성되기 때문에 정의하지 않아도 될 때가 있다.)
        2. 매개변수 생성자 : 하나 이상의 매개변수를 가지는 생성자

    기본 생성자 정의
        - 원래 default로 만들어진다. return이 없어서 void니까 void를 명시하지 않는다.